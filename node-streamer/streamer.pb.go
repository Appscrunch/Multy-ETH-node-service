// Code generated by protoc-gen-go. DO NOT EDIT.
// source: streamer.proto

/*
Package eth is a generated protocol buffer package.

It is generated from these files:
	streamer.proto

It has these top-level messages:
	IsEmptyResp
	ContractInfo
	TokenInfo
	RejectedTxs
	TxsToCheck
	Multisig
	Balance
	Nonce
	GasPrice
	BlockHeight
	ETHTransaction
	ERC20Info
	ERC20Balances
	ERC20History
	MultisigInfo
	MempoolToDelete
	WatchAddress
	MempoolRecord
	Empty
	RawTx
	AddressToResync
	ERC20Address
	UsersData
	AddressExtended
	ReplyInfo
	ServiceVersion
*/
package eth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type IsEmptyResp struct {
	Empty bool   `protobuf:"varint,1,opt,name=Empty" json:"Empty,omitempty"`
	Error string `protobuf:"bytes,2,opt,name=Error" json:"Error,omitempty"`
}

func (m *IsEmptyResp) Reset()                    { *m = IsEmptyResp{} }
func (m *IsEmptyResp) String() string            { return proto.CompactTextString(m) }
func (*IsEmptyResp) ProtoMessage()               {}
func (*IsEmptyResp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *IsEmptyResp) GetEmpty() bool {
	if m != nil {
		return m.Empty
	}
	return false
}

func (m *IsEmptyResp) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

type ContractInfo struct {
	ConfirmationsRequired int64    `protobuf:"varint,1,opt,name=ConfirmationsRequired" json:"ConfirmationsRequired,omitempty"`
	ContractOwners        []string `protobuf:"bytes,2,rep,name=ContractOwners" json:"ContractOwners,omitempty"`
}

func (m *ContractInfo) Reset()                    { *m = ContractInfo{} }
func (m *ContractInfo) String() string            { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()               {}
func (*ContractInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ContractInfo) GetConfirmationsRequired() int64 {
	if m != nil {
		return m.ConfirmationsRequired
	}
	return 0
}

func (m *ContractInfo) GetContractOwners() []string {
	if m != nil {
		return m.ContractOwners
	}
	return nil
}

type TokenInfo struct {
	ContractAddress string `protobuf:"bytes,1,opt,name=ContractAddress" json:"ContractAddress,omitempty"`
	Balance         string `protobuf:"bytes,2,opt,name=Balance" json:"Balance,omitempty"`
}

func (m *TokenInfo) Reset()                    { *m = TokenInfo{} }
func (m *TokenInfo) String() string            { return proto.CompactTextString(m) }
func (*TokenInfo) ProtoMessage()               {}
func (*TokenInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TokenInfo) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *TokenInfo) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

type RejectedTxs struct {
	RejectedTxs []string `protobuf:"bytes,1,rep,name=RejectedTxs" json:"RejectedTxs,omitempty"`
}

func (m *RejectedTxs) Reset()                    { *m = RejectedTxs{} }
func (m *RejectedTxs) String() string            { return proto.CompactTextString(m) }
func (*RejectedTxs) ProtoMessage()               {}
func (*RejectedTxs) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RejectedTxs) GetRejectedTxs() []string {
	if m != nil {
		return m.RejectedTxs
	}
	return nil
}

type TxsToCheck struct {
	Hash []string `protobuf:"bytes,1,rep,name=Hash" json:"Hash,omitempty"`
}

func (m *TxsToCheck) Reset()                    { *m = TxsToCheck{} }
func (m *TxsToCheck) String() string            { return proto.CompactTextString(m) }
func (*TxsToCheck) ProtoMessage()               {}
func (*TxsToCheck) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TxsToCheck) GetHash() []string {
	if m != nil {
		return m.Hash
	}
	return nil
}

type Multisig struct {
	Confirmations  int64    `protobuf:"varint,1,opt,name=Confirmations" json:"Confirmations,omitempty"`
	FactoryAddress string   `protobuf:"bytes,2,opt,name=FactoryAddress" json:"FactoryAddress,omitempty"`
	TxOfCreation   string   `protobuf:"bytes,3,opt,name=TxOfCreation" json:"TxOfCreation,omitempty"`
	Contract       string   `protobuf:"bytes,4,opt,name=Contract" json:"Contract,omitempty"`
	DeployStatus   int64    `protobuf:"varint,5,opt,name=DeployStatus" json:"DeployStatus,omitempty"`
	Addresses      []string `protobuf:"bytes,6,rep,name=Addresses" json:"Addresses,omitempty"`
}

func (m *Multisig) Reset()                    { *m = Multisig{} }
func (m *Multisig) String() string            { return proto.CompactTextString(m) }
func (*Multisig) ProtoMessage()               {}
func (*Multisig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Multisig) GetConfirmations() int64 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *Multisig) GetFactoryAddress() string {
	if m != nil {
		return m.FactoryAddress
	}
	return ""
}

func (m *Multisig) GetTxOfCreation() string {
	if m != nil {
		return m.TxOfCreation
	}
	return ""
}

func (m *Multisig) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *Multisig) GetDeployStatus() int64 {
	if m != nil {
		return m.DeployStatus
	}
	return 0
}

func (m *Multisig) GetAddresses() []string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

type Balance struct {
	Balance        string `protobuf:"bytes,1,opt,name=Balance" json:"Balance,omitempty"`
	PendingBalance string `protobuf:"bytes,2,opt,name=PendingBalance" json:"PendingBalance,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Balance) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

func (m *Balance) GetPendingBalance() string {
	if m != nil {
		return m.PendingBalance
	}
	return ""
}

type Nonce struct {
	Nonce int64 `protobuf:"varint,1,opt,name=Nonce" json:"Nonce,omitempty"`
}

func (m *Nonce) Reset()                    { *m = Nonce{} }
func (m *Nonce) String() string            { return proto.CompactTextString(m) }
func (*Nonce) ProtoMessage()               {}
func (*Nonce) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Nonce) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

type GasPrice struct {
	Gas string `protobuf:"bytes,1,opt,name=Gas" json:"Gas,omitempty"`
}

func (m *GasPrice) Reset()                    { *m = GasPrice{} }
func (m *GasPrice) String() string            { return proto.CompactTextString(m) }
func (*GasPrice) ProtoMessage()               {}
func (*GasPrice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *GasPrice) GetGas() string {
	if m != nil {
		return m.Gas
	}
	return ""
}

type BlockHeight struct {
	Height int64 `protobuf:"varint,1,opt,name=height" json:"height,omitempty"`
}

func (m *BlockHeight) Reset()                    { *m = BlockHeight{} }
func (m *BlockHeight) String() string            { return proto.CompactTextString(m) }
func (*BlockHeight) ProtoMessage()               {}
func (*BlockHeight) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *BlockHeight) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type ETHTransaction struct {
	UserID           string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	WalletIndex      int32  `protobuf:"varint,2,opt,name=WalletIndex" json:"WalletIndex,omitempty"`
	AddressIndex     int32  `protobuf:"varint,3,opt,name=AddressIndex" json:"AddressIndex,omitempty"`
	Hash             string `protobuf:"bytes,4,opt,name=Hash" json:"Hash,omitempty"`
	From             string `protobuf:"bytes,5,opt,name=From" json:"From,omitempty"`
	To               string `protobuf:"bytes,6,opt,name=To" json:"To,omitempty"`
	Amount           string `protobuf:"bytes,7,opt,name=Amount" json:"Amount,omitempty"`
	Input            string `protobuf:"bytes,8,opt,name=input" json:"input,omitempty"`
	GasPrice         int64  `protobuf:"varint,9,opt,name=GasPrice" json:"GasPrice,omitempty"`
	GasLimit         int64  `protobuf:"varint,10,opt,name=GasLimit" json:"GasLimit,omitempty"`
	Nonce            int32  `protobuf:"varint,11,opt,name=Nonce" json:"Nonce,omitempty"`
	Status           int32  `protobuf:"varint,12,opt,name=Status" json:"Status,omitempty"`
	BlockTime        int64  `protobuf:"varint,13,opt,name=BlockTime" json:"BlockTime,omitempty"`
	TxpoolTime       int64  `protobuf:"varint,14,opt,name=TxpoolTime" json:"TxpoolTime,omitempty"`
	BlockHeight      int64  `protobuf:"varint,15,opt,name=BlockHeight" json:"BlockHeight,omitempty"`
	Resync           bool   `protobuf:"varint,16,opt,name=Resync" json:"Resync,omitempty"`
	Multisig         bool   `protobuf:"varint,17,opt,name=Multisig" json:"Multisig,omitempty"`
	Contract         string `protobuf:"bytes,18,opt,name=Contract" json:"Contract,omitempty"`
	MethodInvoked    string `protobuf:"bytes,19,opt,name=MethodInvoked" json:"MethodInvoked,omitempty"`
	Return           string `protobuf:"bytes,20,opt,name=return" json:"return,omitempty"`
	InvocationStatus bool   `protobuf:"varint,21,opt,name=InvocationStatus" json:"InvocationStatus,omitempty"`
}

func (m *ETHTransaction) Reset()                    { *m = ETHTransaction{} }
func (m *ETHTransaction) String() string            { return proto.CompactTextString(m) }
func (*ETHTransaction) ProtoMessage()               {}
func (*ETHTransaction) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ETHTransaction) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *ETHTransaction) GetWalletIndex() int32 {
	if m != nil {
		return m.WalletIndex
	}
	return 0
}

func (m *ETHTransaction) GetAddressIndex() int32 {
	if m != nil {
		return m.AddressIndex
	}
	return 0
}

func (m *ETHTransaction) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ETHTransaction) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *ETHTransaction) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *ETHTransaction) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *ETHTransaction) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

func (m *ETHTransaction) GetGasPrice() int64 {
	if m != nil {
		return m.GasPrice
	}
	return 0
}

func (m *ETHTransaction) GetGasLimit() int64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *ETHTransaction) GetNonce() int32 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *ETHTransaction) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *ETHTransaction) GetBlockTime() int64 {
	if m != nil {
		return m.BlockTime
	}
	return 0
}

func (m *ETHTransaction) GetTxpoolTime() int64 {
	if m != nil {
		return m.TxpoolTime
	}
	return 0
}

func (m *ETHTransaction) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ETHTransaction) GetResync() bool {
	if m != nil {
		return m.Resync
	}
	return false
}

func (m *ETHTransaction) GetMultisig() bool {
	if m != nil {
		return m.Multisig
	}
	return false
}

func (m *ETHTransaction) GetContract() string {
	if m != nil {
		return m.Contract
	}
	return ""
}

func (m *ETHTransaction) GetMethodInvoked() string {
	if m != nil {
		return m.MethodInvoked
	}
	return ""
}

func (m *ETHTransaction) GetReturn() string {
	if m != nil {
		return m.Return
	}
	return ""
}

func (m *ETHTransaction) GetInvocationStatus() bool {
	if m != nil {
		return m.InvocationStatus
	}
	return false
}

type ERC20Info struct {
	History  []*ERC20History  `protobuf:"bytes,1,rep,name=History" json:"History,omitempty"`
	Balances []*ERC20Balances `protobuf:"bytes,2,rep,name=Balances" json:"Balances,omitempty"`
}

func (m *ERC20Info) Reset()                    { *m = ERC20Info{} }
func (m *ERC20Info) String() string            { return proto.CompactTextString(m) }
func (*ERC20Info) ProtoMessage()               {}
func (*ERC20Info) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ERC20Info) GetHistory() []*ERC20History {
	if m != nil {
		return m.History
	}
	return nil
}

func (m *ERC20Info) GetBalances() []*ERC20Balances {
	if m != nil {
		return m.Balances
	}
	return nil
}

type ERC20Balances struct {
	Address string `protobuf:"bytes,1,opt,name=Address" json:"Address,omitempty"`
	Balance string `protobuf:"bytes,2,opt,name=Balance" json:"Balance,omitempty"`
}

func (m *ERC20Balances) Reset()                    { *m = ERC20Balances{} }
func (m *ERC20Balances) String() string            { return proto.CompactTextString(m) }
func (*ERC20Balances) ProtoMessage()               {}
func (*ERC20Balances) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ERC20Balances) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ERC20Balances) GetBalance() string {
	if m != nil {
		return m.Balance
	}
	return ""
}

type ERC20History struct {
	BlockNumber     string `protobuf:"bytes,1,opt,name=BlockNumber" json:"BlockNumber,omitempty"`
	TimeStamp       string `protobuf:"bytes,2,opt,name=TimeStamp" json:"TimeStamp,omitempty"`
	Hash            string `protobuf:"bytes,3,opt,name=Hash" json:"Hash,omitempty"`
	Nonce           string `protobuf:"bytes,4,opt,name=Nonce" json:"Nonce,omitempty"`
	From            string `protobuf:"bytes,5,opt,name=From" json:"From,omitempty"`
	To              string `protobuf:"bytes,6,opt,name=To" json:"To,omitempty"`
	ContractAddress string `protobuf:"bytes,7,opt,name=ContractAddress" json:"ContractAddress,omitempty"`
	Value           string `protobuf:"bytes,8,opt,name=Value" json:"Value,omitempty"`
	GasPrice        string `protobuf:"bytes,9,opt,name=GasPrice" json:"GasPrice,omitempty"`
	Gas             string `protobuf:"bytes,10,opt,name=Gas" json:"Gas,omitempty"`
	Input           string `protobuf:"bytes,11,opt,name=Input" json:"Input,omitempty"`
}

func (m *ERC20History) Reset()                    { *m = ERC20History{} }
func (m *ERC20History) String() string            { return proto.CompactTextString(m) }
func (*ERC20History) ProtoMessage()               {}
func (*ERC20History) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ERC20History) GetBlockNumber() string {
	if m != nil {
		return m.BlockNumber
	}
	return ""
}

func (m *ERC20History) GetTimeStamp() string {
	if m != nil {
		return m.TimeStamp
	}
	return ""
}

func (m *ERC20History) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

func (m *ERC20History) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *ERC20History) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *ERC20History) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *ERC20History) GetContractAddress() string {
	if m != nil {
		return m.ContractAddress
	}
	return ""
}

func (m *ERC20History) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *ERC20History) GetGasPrice() string {
	if m != nil {
		return m.GasPrice
	}
	return ""
}

func (m *ERC20History) GetGas() string {
	if m != nil {
		return m.Gas
	}
	return ""
}

func (m *ERC20History) GetInput() string {
	if m != nil {
		return m.Input
	}
	return ""
}

type MultisigInfo struct {
	Height int64 `protobuf:"varint,1,opt,name=height" json:"height,omitempty"`
}

func (m *MultisigInfo) Reset()                    { *m = MultisigInfo{} }
func (m *MultisigInfo) String() string            { return proto.CompactTextString(m) }
func (*MultisigInfo) ProtoMessage()               {}
func (*MultisigInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *MultisigInfo) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

type MempoolToDelete struct {
	Hash string `protobuf:"bytes,1,opt,name=hash" json:"hash,omitempty"`
}

func (m *MempoolToDelete) Reset()                    { *m = MempoolToDelete{} }
func (m *MempoolToDelete) String() string            { return proto.CompactTextString(m) }
func (*MempoolToDelete) ProtoMessage()               {}
func (*MempoolToDelete) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *MempoolToDelete) GetHash() string {
	if m != nil {
		return m.Hash
	}
	return ""
}

type WatchAddress struct {
	Address      string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	UserID       string `protobuf:"bytes,2,opt,name=userID" json:"userID,omitempty"`
	WalletIndex  int32  `protobuf:"varint,3,opt,name=WalletIndex" json:"WalletIndex,omitempty"`
	AddressIndex int32  `protobuf:"varint,4,opt,name=AddressIndex" json:"AddressIndex,omitempty"`
}

func (m *WatchAddress) Reset()                    { *m = WatchAddress{} }
func (m *WatchAddress) String() string            { return proto.CompactTextString(m) }
func (*WatchAddress) ProtoMessage()               {}
func (*WatchAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *WatchAddress) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *WatchAddress) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *WatchAddress) GetWalletIndex() int32 {
	if m != nil {
		return m.WalletIndex
	}
	return 0
}

func (m *WatchAddress) GetAddressIndex() int32 {
	if m != nil {
		return m.AddressIndex
	}
	return 0
}

type MempoolRecord struct {
	Category int32  `protobuf:"varint,1,opt,name=category" json:"category,omitempty"`
	HashTX   string `protobuf:"bytes,2,opt,name=hashTX" json:"hashTX,omitempty"`
}

func (m *MempoolRecord) Reset()                    { *m = MempoolRecord{} }
func (m *MempoolRecord) String() string            { return proto.CompactTextString(m) }
func (*MempoolRecord) ProtoMessage()               {}
func (*MempoolRecord) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *MempoolRecord) GetCategory() int32 {
	if m != nil {
		return m.Category
	}
	return 0
}

func (m *MempoolRecord) GetHashTX() string {
	if m != nil {
		return m.HashTX
	}
	return ""
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

type RawTx struct {
	Transaction string `protobuf:"bytes,1,opt,name=transaction" json:"transaction,omitempty"`
}

func (m *RawTx) Reset()                    { *m = RawTx{} }
func (m *RawTx) String() string            { return proto.CompactTextString(m) }
func (*RawTx) ProtoMessage()               {}
func (*RawTx) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *RawTx) GetTransaction() string {
	if m != nil {
		return m.Transaction
	}
	return ""
}

type AddressToResync struct {
	Address string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
}

func (m *AddressToResync) Reset()                    { *m = AddressToResync{} }
func (m *AddressToResync) String() string            { return proto.CompactTextString(m) }
func (*AddressToResync) ProtoMessage()               {}
func (*AddressToResync) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *AddressToResync) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type ERC20Address struct {
	Address      string `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	OnlyBalances bool   `protobuf:"varint,2,opt,name=onlyBalances" json:"onlyBalances,omitempty"`
}

func (m *ERC20Address) Reset()                    { *m = ERC20Address{} }
func (m *ERC20Address) String() string            { return proto.CompactTextString(m) }
func (*ERC20Address) ProtoMessage()               {}
func (*ERC20Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *ERC20Address) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ERC20Address) GetOnlyBalances() bool {
	if m != nil {
		return m.OnlyBalances
	}
	return false
}

type UsersData struct {
	Map            map[string]*AddressExtended `protobuf:"bytes,1,rep,name=map" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	UsersContracts map[string]string           `protobuf:"bytes,2,rep,name=UsersContracts" json:"UsersContracts,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *UsersData) Reset()                    { *m = UsersData{} }
func (m *UsersData) String() string            { return proto.CompactTextString(m) }
func (*UsersData) ProtoMessage()               {}
func (*UsersData) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *UsersData) GetMap() map[string]*AddressExtended {
	if m != nil {
		return m.Map
	}
	return nil
}

func (m *UsersData) GetUsersContracts() map[string]string {
	if m != nil {
		return m.UsersContracts
	}
	return nil
}

type AddressExtended struct {
	UserID       string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	WalletIndex  int32  `protobuf:"varint,2,opt,name=WalletIndex" json:"WalletIndex,omitempty"`
	AddressIndex int32  `protobuf:"varint,3,opt,name=AddressIndex" json:"AddressIndex,omitempty"`
}

func (m *AddressExtended) Reset()                    { *m = AddressExtended{} }
func (m *AddressExtended) String() string            { return proto.CompactTextString(m) }
func (*AddressExtended) ProtoMessage()               {}
func (*AddressExtended) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *AddressExtended) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *AddressExtended) GetWalletIndex() int32 {
	if m != nil {
		return m.WalletIndex
	}
	return 0
}

func (m *AddressExtended) GetAddressIndex() int32 {
	if m != nil {
		return m.AddressIndex
	}
	return 0
}

type ReplyInfo struct {
	Message string `protobuf:"bytes,1,opt,name=message" json:"message,omitempty"`
}

func (m *ReplyInfo) Reset()                    { *m = ReplyInfo{} }
func (m *ReplyInfo) String() string            { return proto.CompactTextString(m) }
func (*ReplyInfo) ProtoMessage()               {}
func (*ReplyInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *ReplyInfo) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type ServiceVersion struct {
	Branch    string `protobuf:"bytes,1,opt,name=branch" json:"branch,omitempty"`
	Commit    string `protobuf:"bytes,2,opt,name=commit" json:"commit,omitempty"`
	Buildtime string `protobuf:"bytes,3,opt,name=buildtime" json:"buildtime,omitempty"`
	Lasttag   string `protobuf:"bytes,4,opt,name=lasttag" json:"lasttag,omitempty"`
}

func (m *ServiceVersion) Reset()                    { *m = ServiceVersion{} }
func (m *ServiceVersion) String() string            { return proto.CompactTextString(m) }
func (*ServiceVersion) ProtoMessage()               {}
func (*ServiceVersion) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *ServiceVersion) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *ServiceVersion) GetCommit() string {
	if m != nil {
		return m.Commit
	}
	return ""
}

func (m *ServiceVersion) GetBuildtime() string {
	if m != nil {
		return m.Buildtime
	}
	return ""
}

func (m *ServiceVersion) GetLasttag() string {
	if m != nil {
		return m.Lasttag
	}
	return ""
}

func init() {
	proto.RegisterType((*IsEmptyResp)(nil), "eth.IsEmptyResp")
	proto.RegisterType((*ContractInfo)(nil), "eth.ContractInfo")
	proto.RegisterType((*TokenInfo)(nil), "eth.TokenInfo")
	proto.RegisterType((*RejectedTxs)(nil), "eth.RejectedTxs")
	proto.RegisterType((*TxsToCheck)(nil), "eth.TxsToCheck")
	proto.RegisterType((*Multisig)(nil), "eth.Multisig")
	proto.RegisterType((*Balance)(nil), "eth.Balance")
	proto.RegisterType((*Nonce)(nil), "eth.Nonce")
	proto.RegisterType((*GasPrice)(nil), "eth.GasPrice")
	proto.RegisterType((*BlockHeight)(nil), "eth.BlockHeight")
	proto.RegisterType((*ETHTransaction)(nil), "eth.ETHTransaction")
	proto.RegisterType((*ERC20Info)(nil), "eth.ERC20Info")
	proto.RegisterType((*ERC20Balances)(nil), "eth.ERC20Balances")
	proto.RegisterType((*ERC20History)(nil), "eth.ERC20History")
	proto.RegisterType((*MultisigInfo)(nil), "eth.MultisigInfo")
	proto.RegisterType((*MempoolToDelete)(nil), "eth.MempoolToDelete")
	proto.RegisterType((*WatchAddress)(nil), "eth.WatchAddress")
	proto.RegisterType((*MempoolRecord)(nil), "eth.MempoolRecord")
	proto.RegisterType((*Empty)(nil), "eth.Empty")
	proto.RegisterType((*RawTx)(nil), "eth.RawTx")
	proto.RegisterType((*AddressToResync)(nil), "eth.AddressToResync")
	proto.RegisterType((*ERC20Address)(nil), "eth.ERC20Address")
	proto.RegisterType((*UsersData)(nil), "eth.UsersData")
	proto.RegisterType((*AddressExtended)(nil), "eth.AddressExtended")
	proto.RegisterType((*ReplyInfo)(nil), "eth.ReplyInfo")
	proto.RegisterType((*ServiceVersion)(nil), "eth.ServiceVersion")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for NodeCommunications service

type NodeCommunicationsClient interface {
	ServiceInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServiceVersion, error)
	EventGetGasPrice(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GasPrice, error)
	EventInitialAdd(ctx context.Context, in *UsersData, opts ...grpc.CallOption) (*ReplyInfo, error)
	EventAddNewAddress(ctx context.Context, in *WatchAddress, opts ...grpc.CallOption) (*ReplyInfo, error)
	EventAddNewMultisig(ctx context.Context, in *WatchAddress, opts ...grpc.CallOption) (*ReplyInfo, error)
	EventGetBlockHeight(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockHeight, error)
	EventGetCode(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ReplyInfo, error)
	EventGetAdressNonce(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*Nonce, error)
	EventGetAdressBalance(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*Balance, error)
	EventGetAllMempool(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventGetAllMempoolClient, error)
	EventAddMempoolRecord(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventAddMempoolRecordClient, error)
	EventDeleteMempool(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventDeleteMempoolClient, error)
	EventResyncAddress(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ReplyInfo, error)
	EventNewBlock(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventNewBlockClient, error)
	CheckRejectTxs(ctx context.Context, in *TxsToCheck, opts ...grpc.CallOption) (*RejectedTxs, error)
	EventSendRawTx(ctx context.Context, in *RawTx, opts ...grpc.CallOption) (*ReplyInfo, error)
	NewTx(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_NewTxClient, error)
	SyncState(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*ReplyInfo, error)
	//  Multisig methods
	AddMultisig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_AddMultisigClient, error)
	GetMultisigInfo(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ContractInfo, error)
	// erc20 methods
	GetERC20Info(ctx context.Context, in *ERC20Address, opts ...grpc.CallOption) (*ERC20Info, error)
	// import external seed
	IsEmptyAddress(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*IsEmptyResp, error)
}

type nodeCommunicationsClient struct {
	cc *grpc.ClientConn
}

func NewNodeCommunicationsClient(cc *grpc.ClientConn) NodeCommunicationsClient {
	return &nodeCommunicationsClient{cc}
}

func (c *nodeCommunicationsClient) ServiceInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ServiceVersion, error) {
	out := new(ServiceVersion)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/ServiceInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetGasPrice(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*GasPrice, error) {
	out := new(GasPrice)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventGetGasPrice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventInitialAdd(ctx context.Context, in *UsersData, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventInitialAdd", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventAddNewAddress(ctx context.Context, in *WatchAddress, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventAddNewAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventAddNewMultisig(ctx context.Context, in *WatchAddress, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventAddNewMultisig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetBlockHeight(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*BlockHeight, error) {
	out := new(BlockHeight)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventGetBlockHeight", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetCode(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventGetCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetAdressNonce(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*Nonce, error) {
	out := new(Nonce)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventGetAdressNonce", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetAdressBalance(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*Balance, error) {
	out := new(Balance)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventGetAdressBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventGetAllMempool(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventGetAllMempoolClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[0], c.cc, "/eth.NodeCommunications/EventGetAllMempool", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsEventGetAllMempoolClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_EventGetAllMempoolClient interface {
	Recv() (*MempoolRecord, error)
	grpc.ClientStream
}

type nodeCommunicationsEventGetAllMempoolClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsEventGetAllMempoolClient) Recv() (*MempoolRecord, error) {
	m := new(MempoolRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) EventAddMempoolRecord(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventAddMempoolRecordClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[1], c.cc, "/eth.NodeCommunications/EventAddMempoolRecord", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsEventAddMempoolRecordClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_EventAddMempoolRecordClient interface {
	Recv() (*MempoolRecord, error)
	grpc.ClientStream
}

type nodeCommunicationsEventAddMempoolRecordClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsEventAddMempoolRecordClient) Recv() (*MempoolRecord, error) {
	m := new(MempoolRecord)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) EventDeleteMempool(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventDeleteMempoolClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[2], c.cc, "/eth.NodeCommunications/EventDeleteMempool", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsEventDeleteMempoolClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_EventDeleteMempoolClient interface {
	Recv() (*MempoolToDelete, error)
	grpc.ClientStream
}

type nodeCommunicationsEventDeleteMempoolClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsEventDeleteMempoolClient) Recv() (*MempoolToDelete, error) {
	m := new(MempoolToDelete)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) EventResyncAddress(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventResyncAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventNewBlock(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_EventNewBlockClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[3], c.cc, "/eth.NodeCommunications/EventNewBlock", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsEventNewBlockClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_EventNewBlockClient interface {
	Recv() (*BlockHeight, error)
	grpc.ClientStream
}

type nodeCommunicationsEventNewBlockClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsEventNewBlockClient) Recv() (*BlockHeight, error) {
	m := new(BlockHeight)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) CheckRejectTxs(ctx context.Context, in *TxsToCheck, opts ...grpc.CallOption) (*RejectedTxs, error) {
	out := new(RejectedTxs)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/CheckRejectTxs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) EventSendRawTx(ctx context.Context, in *RawTx, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/EventSendRawTx", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) NewTx(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_NewTxClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[4], c.cc, "/eth.NodeCommunications/NewTx", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsNewTxClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_NewTxClient interface {
	Recv() (*ETHTransaction, error)
	grpc.ClientStream
}

type nodeCommunicationsNewTxClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsNewTxClient) Recv() (*ETHTransaction, error) {
	m := new(ETHTransaction)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) SyncState(ctx context.Context, in *BlockHeight, opts ...grpc.CallOption) (*ReplyInfo, error) {
	out := new(ReplyInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/SyncState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) AddMultisig(ctx context.Context, in *Empty, opts ...grpc.CallOption) (NodeCommunications_AddMultisigClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_NodeCommunications_serviceDesc.Streams[5], c.cc, "/eth.NodeCommunications/AddMultisig", opts...)
	if err != nil {
		return nil, err
	}
	x := &nodeCommunicationsAddMultisigClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type NodeCommunications_AddMultisigClient interface {
	Recv() (*Multisig, error)
	grpc.ClientStream
}

type nodeCommunicationsAddMultisigClient struct {
	grpc.ClientStream
}

func (x *nodeCommunicationsAddMultisigClient) Recv() (*Multisig, error) {
	m := new(Multisig)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *nodeCommunicationsClient) GetMultisigInfo(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*ContractInfo, error) {
	out := new(ContractInfo)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/GetMultisigInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) GetERC20Info(ctx context.Context, in *ERC20Address, opts ...grpc.CallOption) (*ERC20Info, error) {
	out := new(ERC20Info)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/GetERC20Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeCommunicationsClient) IsEmptyAddress(ctx context.Context, in *AddressToResync, opts ...grpc.CallOption) (*IsEmptyResp, error) {
	out := new(IsEmptyResp)
	err := grpc.Invoke(ctx, "/eth.NodeCommunications/IsEmptyAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for NodeCommunications service

type NodeCommunicationsServer interface {
	ServiceInfo(context.Context, *Empty) (*ServiceVersion, error)
	EventGetGasPrice(context.Context, *Empty) (*GasPrice, error)
	EventInitialAdd(context.Context, *UsersData) (*ReplyInfo, error)
	EventAddNewAddress(context.Context, *WatchAddress) (*ReplyInfo, error)
	EventAddNewMultisig(context.Context, *WatchAddress) (*ReplyInfo, error)
	EventGetBlockHeight(context.Context, *Empty) (*BlockHeight, error)
	EventGetCode(context.Context, *AddressToResync) (*ReplyInfo, error)
	EventGetAdressNonce(context.Context, *AddressToResync) (*Nonce, error)
	EventGetAdressBalance(context.Context, *AddressToResync) (*Balance, error)
	EventGetAllMempool(*Empty, NodeCommunications_EventGetAllMempoolServer) error
	EventAddMempoolRecord(*Empty, NodeCommunications_EventAddMempoolRecordServer) error
	EventDeleteMempool(*Empty, NodeCommunications_EventDeleteMempoolServer) error
	EventResyncAddress(context.Context, *AddressToResync) (*ReplyInfo, error)
	EventNewBlock(*Empty, NodeCommunications_EventNewBlockServer) error
	CheckRejectTxs(context.Context, *TxsToCheck) (*RejectedTxs, error)
	EventSendRawTx(context.Context, *RawTx) (*ReplyInfo, error)
	NewTx(*Empty, NodeCommunications_NewTxServer) error
	SyncState(context.Context, *BlockHeight) (*ReplyInfo, error)
	//  Multisig methods
	AddMultisig(*Empty, NodeCommunications_AddMultisigServer) error
	GetMultisigInfo(context.Context, *AddressToResync) (*ContractInfo, error)
	// erc20 methods
	GetERC20Info(context.Context, *ERC20Address) (*ERC20Info, error)
	// import external seed
	IsEmptyAddress(context.Context, *AddressToResync) (*IsEmptyResp, error)
}

func RegisterNodeCommunicationsServer(s *grpc.Server, srv NodeCommunicationsServer) {
	s.RegisterService(&_NodeCommunications_serviceDesc, srv)
}

func _NodeCommunications_ServiceInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).ServiceInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/ServiceInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).ServiceInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetGasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventGetGasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventGetGasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventGetGasPrice(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventInitialAdd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventInitialAdd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventInitialAdd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventInitialAdd(ctx, req.(*UsersData))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventAddNewAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WatchAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventAddNewAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventAddNewAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventAddNewAddress(ctx, req.(*WatchAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventAddNewMultisig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WatchAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventAddNewMultisig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventAddNewMultisig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventAddNewMultisig(ctx, req.(*WatchAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetBlockHeight_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventGetBlockHeight(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventGetBlockHeight",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventGetBlockHeight(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventGetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventGetCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventGetCode(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetAdressNonce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventGetAdressNonce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventGetAdressNonce",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventGetAdressNonce(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetAdressBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventGetAdressBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventGetAdressBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventGetAdressBalance(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventGetAllMempool_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).EventGetAllMempool(m, &nodeCommunicationsEventGetAllMempoolServer{stream})
}

type NodeCommunications_EventGetAllMempoolServer interface {
	Send(*MempoolRecord) error
	grpc.ServerStream
}

type nodeCommunicationsEventGetAllMempoolServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsEventGetAllMempoolServer) Send(m *MempoolRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_EventAddMempoolRecord_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).EventAddMempoolRecord(m, &nodeCommunicationsEventAddMempoolRecordServer{stream})
}

type NodeCommunications_EventAddMempoolRecordServer interface {
	Send(*MempoolRecord) error
	grpc.ServerStream
}

type nodeCommunicationsEventAddMempoolRecordServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsEventAddMempoolRecordServer) Send(m *MempoolRecord) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_EventDeleteMempool_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).EventDeleteMempool(m, &nodeCommunicationsEventDeleteMempoolServer{stream})
}

type NodeCommunications_EventDeleteMempoolServer interface {
	Send(*MempoolToDelete) error
	grpc.ServerStream
}

type nodeCommunicationsEventDeleteMempoolServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsEventDeleteMempoolServer) Send(m *MempoolToDelete) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_EventResyncAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventResyncAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventResyncAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventResyncAddress(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventNewBlock_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).EventNewBlock(m, &nodeCommunicationsEventNewBlockServer{stream})
}

type NodeCommunications_EventNewBlockServer interface {
	Send(*BlockHeight) error
	grpc.ServerStream
}

type nodeCommunicationsEventNewBlockServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsEventNewBlockServer) Send(m *BlockHeight) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_CheckRejectTxs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TxsToCheck)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).CheckRejectTxs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/CheckRejectTxs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).CheckRejectTxs(ctx, req.(*TxsToCheck))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_EventSendRawTx_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawTx)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).EventSendRawTx(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/EventSendRawTx",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).EventSendRawTx(ctx, req.(*RawTx))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_NewTx_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).NewTx(m, &nodeCommunicationsNewTxServer{stream})
}

type NodeCommunications_NewTxServer interface {
	Send(*ETHTransaction) error
	grpc.ServerStream
}

type nodeCommunicationsNewTxServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsNewTxServer) Send(m *ETHTransaction) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_SyncState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockHeight)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).SyncState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/SyncState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).SyncState(ctx, req.(*BlockHeight))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_AddMultisig_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(NodeCommunicationsServer).AddMultisig(m, &nodeCommunicationsAddMultisigServer{stream})
}

type NodeCommunications_AddMultisigServer interface {
	Send(*Multisig) error
	grpc.ServerStream
}

type nodeCommunicationsAddMultisigServer struct {
	grpc.ServerStream
}

func (x *nodeCommunicationsAddMultisigServer) Send(m *Multisig) error {
	return x.ServerStream.SendMsg(m)
}

func _NodeCommunications_GetMultisigInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).GetMultisigInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/GetMultisigInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).GetMultisigInfo(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_GetERC20Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).GetERC20Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/GetERC20Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).GetERC20Info(ctx, req.(*ERC20Address))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeCommunications_IsEmptyAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddressToResync)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeCommunicationsServer).IsEmptyAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/eth.NodeCommunications/IsEmptyAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeCommunicationsServer).IsEmptyAddress(ctx, req.(*AddressToResync))
	}
	return interceptor(ctx, in, info, handler)
}

var _NodeCommunications_serviceDesc = grpc.ServiceDesc{
	ServiceName: "eth.NodeCommunications",
	HandlerType: (*NodeCommunicationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ServiceInfo",
			Handler:    _NodeCommunications_ServiceInfo_Handler,
		},
		{
			MethodName: "EventGetGasPrice",
			Handler:    _NodeCommunications_EventGetGasPrice_Handler,
		},
		{
			MethodName: "EventInitialAdd",
			Handler:    _NodeCommunications_EventInitialAdd_Handler,
		},
		{
			MethodName: "EventAddNewAddress",
			Handler:    _NodeCommunications_EventAddNewAddress_Handler,
		},
		{
			MethodName: "EventAddNewMultisig",
			Handler:    _NodeCommunications_EventAddNewMultisig_Handler,
		},
		{
			MethodName: "EventGetBlockHeight",
			Handler:    _NodeCommunications_EventGetBlockHeight_Handler,
		},
		{
			MethodName: "EventGetCode",
			Handler:    _NodeCommunications_EventGetCode_Handler,
		},
		{
			MethodName: "EventGetAdressNonce",
			Handler:    _NodeCommunications_EventGetAdressNonce_Handler,
		},
		{
			MethodName: "EventGetAdressBalance",
			Handler:    _NodeCommunications_EventGetAdressBalance_Handler,
		},
		{
			MethodName: "EventResyncAddress",
			Handler:    _NodeCommunications_EventResyncAddress_Handler,
		},
		{
			MethodName: "CheckRejectTxs",
			Handler:    _NodeCommunications_CheckRejectTxs_Handler,
		},
		{
			MethodName: "EventSendRawTx",
			Handler:    _NodeCommunications_EventSendRawTx_Handler,
		},
		{
			MethodName: "SyncState",
			Handler:    _NodeCommunications_SyncState_Handler,
		},
		{
			MethodName: "GetMultisigInfo",
			Handler:    _NodeCommunications_GetMultisigInfo_Handler,
		},
		{
			MethodName: "GetERC20Info",
			Handler:    _NodeCommunications_GetERC20Info_Handler,
		},
		{
			MethodName: "IsEmptyAddress",
			Handler:    _NodeCommunications_IsEmptyAddress_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "EventGetAllMempool",
			Handler:       _NodeCommunications_EventGetAllMempool_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventAddMempoolRecord",
			Handler:       _NodeCommunications_EventAddMempoolRecord_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventDeleteMempool",
			Handler:       _NodeCommunications_EventDeleteMempool_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventNewBlock",
			Handler:       _NodeCommunications_EventNewBlock_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "NewTx",
			Handler:       _NodeCommunications_NewTx_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AddMultisig",
			Handler:       _NodeCommunications_AddMultisig_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "streamer.proto",
}

func init() { proto.RegisterFile("streamer.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1492 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x17, 0xdb, 0x52, 0x1b, 0xc7,
	0x52, 0x42, 0x08, 0x50, 0x4b, 0x08, 0x3c, 0x60, 0x9f, 0x2d, 0xca, 0xe7, 0x14, 0x35, 0x65, 0xbb,
	0xb0, 0x7d, 0x0a, 0x73, 0xf0, 0x71, 0xca, 0x76, 0x92, 0x07, 0x2c, 0x30, 0x90, 0x18, 0xec, 0x5a,
	0x14, 0x3b, 0xaf, 0xc3, 0x6e, 0x1b, 0x6d, 0x58, 0xed, 0x28, 0xbb, 0x23, 0x40, 0x3f, 0x90, 0x1f,
	0xc8, 0x0f, 0xe4, 0x9f, 0x92, 0xa7, 0x7c, 0x4d, 0x6a, 0x7a, 0x66, 0x56, 0xbb, 0x42, 0x0e, 0xbc,
	0xe4, 0x6d, 0xfa, 0x36, 0x7d, 0xef, 0x9e, 0x81, 0x76, 0xa6, 0x52, 0x14, 0x7d, 0x4c, 0x37, 0x07,
	0xa9, 0x54, 0x92, 0xd5, 0x50, 0xf5, 0xf8, 0x2b, 0x68, 0x1e, 0x66, 0x7b, 0xfd, 0x81, 0x1a, 0xf9,
	0x98, 0x0d, 0xd8, 0x2a, 0xd4, 0x09, 0xf0, 0xaa, 0xeb, 0xd5, 0x8d, 0x05, 0xdf, 0x00, 0x84, 0x4d,
	0x53, 0x99, 0x7a, 0x33, 0xeb, 0xd5, 0x8d, 0x86, 0x6f, 0x00, 0x1e, 0x43, 0xab, 0x23, 0x13, 0x95,
	0x8a, 0x40, 0x1d, 0x26, 0x9f, 0x25, 0xfb, 0x3f, 0xdc, 0xed, 0xc8, 0xe4, 0x73, 0x94, 0xf6, 0x85,
	0x8a, 0x64, 0x92, 0xf9, 0xf8, 0xf3, 0x30, 0x4a, 0x31, 0xa4, 0xbb, 0x6a, 0xfe, 0x74, 0x22, 0x7b,
	0x04, 0x6d, 0x77, 0xcb, 0xfb, 0xcb, 0x04, 0xd3, 0xcc, 0x9b, 0x59, 0xaf, 0x6d, 0x34, 0xfc, 0x09,
	0x2c, 0x7f, 0x0f, 0x8d, 0xae, 0x3c, 0xc7, 0x84, 0x54, 0x6d, 0xc0, 0x92, 0x23, 0xef, 0x84, 0x61,
	0x8a, 0x59, 0x46, 0x4a, 0x1a, 0xfe, 0x24, 0x9a, 0x79, 0x30, 0xff, 0x46, 0xc4, 0x22, 0x09, 0xd0,
	0x1a, 0xef, 0x40, 0xfe, 0x0c, 0x9a, 0x3e, 0xfe, 0x84, 0x81, 0xc2, 0xb0, 0x7b, 0x95, 0xb1, 0xf5,
	0x12, 0xe8, 0x55, 0xc9, 0x88, 0x22, 0x8a, 0xaf, 0x03, 0x74, 0xaf, 0xb2, 0xae, 0xec, 0xf4, 0x30,
	0x38, 0x67, 0x0c, 0x66, 0x0f, 0x44, 0xd6, 0xb3, 0x8c, 0x74, 0xe6, 0x7f, 0x56, 0x61, 0xe1, 0x68,
	0x18, 0xab, 0x28, 0x8b, 0xce, 0xd8, 0x03, 0x58, 0x2c, 0x79, 0x6c, 0xc3, 0x50, 0x46, 0x6a, 0xf7,
	0xdf, 0x8a, 0x40, 0xc9, 0x74, 0xe4, 0x1c, 0x31, 0x66, 0x4e, 0x60, 0x19, 0x87, 0x56, 0xf7, 0xea,
	0xfd, 0xe7, 0x4e, 0x8a, 0x24, 0xe8, 0xd5, 0x88, 0xab, 0x84, 0x63, 0x6b, 0xb0, 0xe0, 0xdc, 0xf7,
	0x66, 0x89, 0x9e, 0xc3, 0x5a, 0x7e, 0x17, 0x07, 0xb1, 0x1c, 0x9d, 0x28, 0xa1, 0x86, 0x99, 0x57,
	0x27, 0x63, 0x4a, 0x38, 0x76, 0x1f, 0x1a, 0x56, 0x1d, 0x66, 0xde, 0x1c, 0xf9, 0x35, 0x46, 0xf0,
	0xef, 0xf3, 0x48, 0x16, 0x83, 0x5a, 0x2d, 0x05, 0x55, 0xbb, 0xf3, 0x01, 0x93, 0x30, 0x4a, 0xce,
	0xca, 0x51, 0x9f, 0xc0, 0xf2, 0x7f, 0x43, 0xfd, 0x58, 0x6a, 0x81, 0x55, 0x7b, 0xb0, 0xd1, 0x31,
	0x00, 0xbf, 0x0f, 0x0b, 0xfb, 0x22, 0xfb, 0x90, 0x46, 0x01, 0xb2, 0x65, 0xa8, 0xed, 0x0b, 0x97,
	0x5f, 0x7d, 0xe4, 0x0f, 0xa1, 0xf9, 0x26, 0x96, 0xc1, 0xf9, 0x01, 0x46, 0x67, 0x3d, 0xc5, 0xee,
	0xc1, 0x5c, 0x8f, 0x4e, 0xf6, 0x0e, 0x0b, 0xf1, 0x3f, 0x66, 0xa1, 0xbd, 0xd7, 0x3d, 0xe8, 0xa6,
	0x22, 0xc9, 0x44, 0x40, 0x11, 0xba, 0x07, 0x73, 0x3f, 0x64, 0x98, 0x1e, 0xee, 0xda, 0xeb, 0x2c,
	0xa4, 0x93, 0xff, 0x49, 0xc4, 0x31, 0xaa, 0xc3, 0x24, 0xc4, 0x2b, 0xb2, 0xb9, 0xee, 0x17, 0x51,
	0x3a, 0x7e, 0x36, 0x14, 0x86, 0xa5, 0x46, 0x2c, 0x25, 0x5c, 0x5e, 0x12, 0x26, 0xf6, 0x74, 0xd6,
	0xb8, 0xb7, 0xa9, 0xec, 0x53, 0xbc, 0x1b, 0x3e, 0x9d, 0x59, 0x1b, 0x66, 0xba, 0xd2, 0x9b, 0x23,
	0xcc, 0x4c, 0x57, 0x6a, 0xab, 0x76, 0xfa, 0x72, 0x98, 0x28, 0x6f, 0xde, 0x58, 0x65, 0x20, 0x1d,
	0x9b, 0x28, 0x19, 0x0c, 0x95, 0xb7, 0x60, 0xda, 0x8e, 0x00, 0x9d, 0x65, 0x17, 0x1b, 0xaf, 0x41,
	0x0e, 0x8f, 0x63, 0x65, 0x68, 0xef, 0xa2, 0x7e, 0xa4, 0x3c, 0xc8, 0x69, 0x04, 0x8f, 0x23, 0xdd,
	0x24, 0xd3, 0x6d, 0xfc, 0xef, 0xc1, 0x9c, 0xad, 0x88, 0x16, 0xa1, 0xe7, 0xc6, 0xb5, 0x40, 0x31,
	0xee, 0x46, 0x7d, 0xf4, 0x16, 0xe9, 0xaa, 0x31, 0x82, 0xfd, 0x47, 0xb7, 0xc2, 0x40, 0xca, 0x98,
	0xc8, 0x6d, 0x22, 0x17, 0x30, 0x3a, 0x9e, 0x85, 0x0c, 0x79, 0x4b, 0xc4, 0x30, 0x99, 0x34, 0x1f,
	0xb3, 0x51, 0x12, 0x78, 0xcb, 0x34, 0x69, 0x2c, 0xa4, 0x3d, 0x70, 0x1d, 0xe4, 0xdd, 0x21, 0xca,
	0xb8, 0xa3, 0x8a, 0xf5, 0xcd, 0x26, 0xea, 0xfb, 0x01, 0x2c, 0x1e, 0xa1, 0xea, 0xc9, 0xf0, 0x30,
	0xb9, 0x90, 0xe7, 0x18, 0x7a, 0x2b, 0xc4, 0x50, 0x46, 0x6a, 0xad, 0x29, 0xaa, 0x61, 0x9a, 0x78,
	0xab, 0x26, 0xd2, 0x06, 0x62, 0x4f, 0x60, 0x59, 0xb3, 0x04, 0xd4, 0x47, 0x36, 0x1e, 0x77, 0x49,
	0xfb, 0x35, 0x3c, 0xef, 0x41, 0x63, 0xcf, 0xef, 0x6c, 0x6f, 0xd1, 0x20, 0x7a, 0x0a, 0xf3, 0x07,
	0x51, 0xa6, 0x1b, 0x95, 0x06, 0x41, 0x73, 0xfb, 0xce, 0x26, 0xaa, 0xde, 0x26, 0x31, 0x58, 0x82,
	0xef, 0x38, 0xd8, 0x26, 0x2c, 0xd8, 0xfa, 0x37, 0x43, 0xae, 0xb9, 0xcd, 0xc6, 0xdc, 0x8e, 0xe2,
	0xe7, 0x3c, 0xbc, 0x03, 0x8b, 0x25, 0x92, 0xee, 0xbb, 0xf2, 0xb8, 0x9b, 0xbf, 0x79, 0xcc, 0xfd,
	0x36, 0x03, 0xad, 0xa2, 0x39, 0x79, 0x6e, 0x8e, 0x87, 0xfd, 0x53, 0x4c, 0xed, 0x45, 0x45, 0x94,
	0xce, 0xbd, 0xce, 0xe2, 0x89, 0x12, 0xfd, 0x81, 0xbd, 0x6e, 0x8c, 0xc8, 0xab, 0xbc, 0x56, 0xa8,
	0xf2, 0xbc, 0xb6, 0x4c, 0xe9, 0xdb, 0xda, 0xba, 0x4d, 0xed, 0x4f, 0x99, 0xe4, 0xf3, 0xd3, 0x27,
	0xf9, 0x2a, 0xd4, 0x3f, 0x8a, 0x78, 0x88, 0xae, 0x1b, 0x08, 0xb8, 0xd6, 0x0d, 0x0d, 0xff, 0xda,
	0xe4, 0x80, 0x7c, 0x72, 0xe8, 0x3b, 0x0e, 0xa9, 0xa3, 0x9a, 0xe6, 0x0e, 0x02, 0xf8, 0x23, 0x68,
	0xb9, 0x1a, 0xa3, 0xa4, 0x7e, 0x69, 0xa0, 0x3c, 0x84, 0xa5, 0x23, 0xec, 0x53, 0x91, 0xcb, 0x5d,
	0x8c, 0x51, 0x91, 0x8b, 0x3d, 0xb3, 0x05, 0xc8, 0x45, 0x7d, 0xe6, 0xbf, 0x54, 0xa1, 0xf5, 0x49,
	0xa8, 0xa0, 0x57, 0x48, 0x8e, 0x28, 0xa7, 0xcd, 0x82, 0x5a, 0xd3, 0xd0, 0xcc, 0x23, 0x13, 0x66,
	0x0b, 0x4d, 0xce, 0xa3, 0xda, 0xcd, 0xf3, 0x68, 0xf6, 0xfa, 0x3c, 0xd2, 0xf5, 0x63, 0xed, 0xf5,
	0x31, 0x90, 0x69, 0xa8, 0x83, 0x15, 0x08, 0x85, 0x67, 0xa6, 0x5c, 0xb5, 0x40, 0x0e, 0x93, 0xd3,
	0x22, 0xeb, 0x75, 0x7f, 0x74, 0xa6, 0x18, 0x88, 0xcf, 0xdb, 0x17, 0x01, 0x7f, 0x0c, 0x75, 0x5f,
	0x5c, 0x76, 0xaf, 0xb4, 0x71, 0x6a, 0x3c, 0x53, 0x5d, 0x01, 0x15, 0x50, 0xfc, 0x29, 0x2c, 0x59,
	0x43, 0xba, 0xd2, 0xf6, 0xf5, 0x17, 0x63, 0xc0, 0xdf, 0xd9, 0xfa, 0xbc, 0x39, 0x5a, 0x1c, 0x5a,
	0x32, 0x89, 0x47, 0x85, 0x1e, 0xd2, 0x1d, 0x5a, 0xc2, 0xf1, 0x5f, 0x67, 0xa0, 0xa1, 0x87, 0x7a,
	0xb6, 0x2b, 0x94, 0x60, 0x8f, 0xa1, 0xd6, 0x17, 0x03, 0xdb, 0x9a, 0xff, 0xa2, 0x66, 0xcb, 0x89,
	0x9b, 0x47, 0x62, 0xb0, 0x97, 0xa8, 0x74, 0xe4, 0x6b, 0x1e, 0xf6, 0x1d, 0xb4, 0x89, 0xe4, 0xca,
	0xce, 0xb5, 0x28, 0x9f, 0x90, 0x2a, 0x33, 0x99, 0x0b, 0x26, 0x24, 0xd7, 0xde, 0xc1, 0x82, 0xbb,
	0x5c, 0x17, 0xe1, 0x39, 0x8e, 0xdc, 0xfa, 0x3a, 0xc7, 0x11, 0x7b, 0x02, 0xf5, 0x0b, 0x2a, 0x64,
	0x6d, 0x7f, 0x73, 0x7b, 0x95, 0x14, 0x58, 0xef, 0xf7, 0xae, 0x14, 0x26, 0x21, 0x86, 0xbe, 0x61,
	0x79, 0x3d, 0xf3, 0xb2, 0xba, 0xb6, 0x03, 0x2b, 0x53, 0x94, 0x4e, 0xb9, 0x78, 0xb5, 0x78, 0x71,
	0xa3, 0x70, 0x05, 0x97, 0x79, 0x42, 0x9c, 0x82, 0x7f, 0x76, 0x15, 0xf2, 0x87, 0xd0, 0xf0, 0x71,
	0x10, 0x8f, 0xa8, 0x9f, 0x3c, 0x98, 0xef, 0x63, 0x96, 0x89, 0xb3, 0xfc, 0xb9, 0x60, 0x41, 0x7e,
	0x05, 0xed, 0x13, 0x4c, 0x2f, 0xa2, 0x00, 0x3f, 0x62, 0x9a, 0xd9, 0x0d, 0x7d, 0x9a, 0x8a, 0x24,
	0x70, 0x2d, 0x65, 0x21, 0x8d, 0x0f, 0x64, 0x5f, 0xef, 0x35, 0x5b, 0x9e, 0x06, 0xd2, 0xb3, 0xea,
	0x74, 0x18, 0xc5, 0xa1, 0xd2, 0x8b, 0xc8, 0x8c, 0xa4, 0x31, 0x42, 0x6b, 0x8e, 0x45, 0xa6, 0x94,
	0x38, 0xb3, 0x93, 0xc9, 0x81, 0xdb, 0xbf, 0x37, 0x80, 0x1d, 0xcb, 0x10, 0x3b, 0xb2, 0xdf, 0x1f,
	0x26, 0x51, 0x60, 0x9f, 0x63, 0x5b, 0xd0, 0xb4, 0x06, 0x91, 0xe5, 0x60, 0xe6, 0xb3, 0xae, 0xff,
	0xb5, 0x15, 0x3a, 0x97, 0xcd, 0xe5, 0x15, 0xf6, 0x0c, 0x96, 0xf7, 0x2e, 0x30, 0x51, 0xfb, 0xa8,
	0xf2, 0xc1, 0x53, 0x14, 0x5b, 0xa4, 0xb3, 0x23, 0xf1, 0x0a, 0x7b, 0x0e, 0x4b, 0x24, 0x70, 0x98,
	0x44, 0x2a, 0x12, 0xf1, 0x4e, 0x18, 0xb2, 0x76, 0xb9, 0xc6, 0xd6, 0x0c, 0x9c, 0x07, 0x90, 0x57,
	0xd8, 0x2b, 0x60, 0x24, 0xb4, 0x13, 0x86, 0xc7, 0x78, 0xe9, 0x5a, 0xc5, 0x2c, 0x9b, 0xe2, 0xac,
	0x99, 0x22, 0xfa, 0x1a, 0x56, 0x0a, 0xa2, 0xf9, 0x32, 0xbd, 0x95, 0xec, 0x0b, 0x2b, 0xbb, 0x8f,
	0xaa, 0xb8, 0xbc, 0x8b, 0xfe, 0x2d, 0xd3, 0xb9, 0x40, 0xe5, 0x15, 0xf6, 0x15, 0xb4, 0x9c, 0x58,
	0x47, 0x86, 0xc8, 0x4a, 0x25, 0xee, 0x46, 0xc2, 0x54, 0x2f, 0x73, 0x75, 0x3b, 0xc4, 0x6b, 0xdf,
	0x88, 0x53, 0xc5, 0x8d, 0x11, 0xe6, 0xbd, 0x58, 0x61, 0xdf, 0xc2, 0xdd, 0xb2, 0xa8, 0x7b, 0x91,
	0x4e, 0x17, 0x6e, 0x19, 0xab, 0xed, 0x8e, 0xac, 0xb0, 0x97, 0x36, 0xbe, 0x5a, 0x3c, 0x8e, 0xed,
	0xd4, 0x2c, 0xf9, 0x69, 0x56, 0x75, 0x69, 0x9e, 0xf2, 0xca, 0x56, 0x95, 0x7d, 0x6d, 0x15, 0xef,
	0x84, 0x61, 0x79, 0xd8, 0xde, 0x46, 0xf8, 0xb5, 0x55, 0x6b, 0xb6, 0xc9, 0x34, 0xb5, 0xab, 0x45,
	0x49, 0xb7, 0x76, 0x48, 0xf6, 0x1b, 0x2b, 0x6b, 0x3c, 0xca, 0xb7, 0xe4, 0x2d, 0x43, 0xfd, 0x3f,
	0x58, 0x24, 0xe9, 0x63, 0xbc, 0xa4, 0xdc, 0xdd, 0x94, 0xd3, 0xad, 0x2a, 0x7b, 0x01, 0x6d, 0xfa,
	0xfa, 0x98, 0x3f, 0x91, 0xfe, 0x33, 0x2d, 0x11, 0xdf, 0xf8, 0x53, 0x64, 0x05, 0x8b, 0x9f, 0xa6,
	0x0a, 0xdb, 0x84, 0x36, 0x69, 0x3a, 0xc1, 0x24, 0x34, 0x0b, 0xc4, 0xa8, 0xa2, 0xf3, 0x14, 0xcb,
	0xfe, 0x0b, 0xf5, 0x63, 0x1c, 0xb3, 0x15, 0x9b, 0xaf, 0xfc, 0x9a, 0x27, 0xa3, 0x9e, 0x41, 0xe3,
	0x64, 0x94, 0x04, 0xfa, 0x6d, 0x86, 0xec, 0x9a, 0xdd, 0x53, 0xaf, 0x6f, 0xea, 0x54, 0xb9, 0x36,
	0xb8, 0xde, 0xaa, 0x8e, 0x64, 0x83, 0xbc, 0xb4, 0x8f, 0xaa, 0xf4, 0x3a, 0x98, 0x1e, 0x61, 0xd3,
	0x4e, 0xc5, 0xff, 0x30, 0xb5, 0x7a, 0x6b, 0x1f, 0xd5, 0xf8, 0xb5, 0x58, 0x78, 0x1c, 0x96, 0x7b,
	0x2e, 0x67, 0xa1, 0x7e, 0x6d, 0xdb, 0x1f, 0xf9, 0xdf, 0xe7, 0xd4, 0x38, 0x5b, 0xf8, 0xbc, 0xf3,
	0xca, 0xe9, 0x1c, 0xfd, 0xec, 0x9f, 0xff, 0x15, 0x00, 0x00, 0xff, 0xff, 0xce, 0x25, 0x27, 0xdb,
	0xeb, 0x0f, 0x00, 0x00,
}
